import type { FeatureChild, GherkinDocument, RuleChild, Step } from "@cucumber/messages";
import type { QuickPickleConfig } from '.'

export function renderFeature(gherkinDocument:GherkinDocument, config:QuickPickleConfig = {}) {

  if (!gherkinDocument?.feature || !gherkinDocument.feature?.children?.length) {
    return ''
  }

  let feature = gherkinDocument.feature!;

  // Render initial output for the file: imports, world variables, beforeAll/afterAll hooks
  let output:string = `// Generated by quickpickle
import { test, describe, beforeAll, afterAll } from 'vitest';
import {
  qp,
  applyBeforeAllHooks,
  applyBeforeHooks,
  applyAfterAllHooks,
  applyAfterHooks,
  getWorldConstructor,
} from 'quickpickle';

let World = getWorldConstructor()
const worldConfig = {}

const common = {};

beforeAll(async () => {
  await applyBeforeAllHooks(common);
});

afterAll(async () => {
  await applyAfterAllHooks(common);
});

const afterScenario = async(state) => {
  await applyAfterHooks(state);
}

`

  // Get the background stes and all the scenarios
  let { backgroundSteps, children } = renderChildren(feature.children as FeatureChild[], config)

  // Render the initScenario function, which will be called at the beginning of each scenario
  output += `
const initScenario = async(scenario, tags) => {
  let state = new World(worldConfig);
  await state.init(worldConfig);
  state.common = common;
  state.info.feature = '${feature.keyword}: ${feature.name}';
  state.info.scenario = scenario;
  state.info.tags.push(...tags);
  await applyBeforeHooks(state);
  ${backgroundSteps}
  qp('a common precondition', state, 10);
  qp('another common precondition', state, 11);
  return state;
}

`

  // render all the scenarios
  output += children

  return output
}

function isRule(child:FeatureChild|RuleChild): child is FeatureChild {
  return child.hasOwnProperty('rule')
}

function renderChildren(children:RuleChild[]|FeatureChild[], config:QuickPickleConfig, sp = '  ') {

  const output = {
    backgroundSteps: '',
    children: '',
  }

  if (!children.length) return output

  if (children[0].hasOwnProperty('background')) {
    output.backgroundSteps = renderSteps(children.shift()!.background!.steps as Step[], config, sp)
  }

  for (let child of children) {
    if (isRule(child)) {
      output.children += renderRule(child, config, sp + '  ')
    }
    else if (child.hasOwnProperty('scenario')) {
      output.children += renderScenario(child, config, sp)
    }
  }

  return output
}

function renderRule(child:FeatureChild, config:QuickPickleConfig, sp = '  ') {
  let { backgroundSteps, children } = renderChildren(child.rule!.children as RuleChild[], config, sp + '  ')

  return `
${sp}describe('${child.rule!.keyword}: ${child.rule!.name}', () => {

${sp}const initRuleScenario = async(scenario, tags) => {
${sp}  let state = await initScenario(scenario, tags);
${sp}  state.info.rule = '${child.rule!.name}';
${backgroundSteps}
${sp}  return state;
}

${children}

${sp}});
`
}

function renderScenario(child:FeatureChild, config:QuickPickleConfig, sp = '  ') {
  let initFn = sp.length > 4 ? 'initRuleScenario' : 'initScenario'
  return `
${sp}test('${child.scenario!.keyword}: ${child.scenario!.name}', async () => {
${sp}  let state = await ${initFn}('${child.scenario!.name}', ['${child.scenario!.tags.map(t => t.name).join('", "') || '""'}']);
${renderSteps(child.scenario!.steps as Step[], config, sp + '  ')}
${sp}  await afterScenario(state);
${sp}});
`
}

function renderSteps(steps:Step[], config:QuickPickleConfig, sp = '  ') {
  return steps.map(step => {
    return `${sp}  qp('${step.text}', state, ${step.location.line});`
  }).join('\n')
}